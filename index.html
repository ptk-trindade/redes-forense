
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <!-- <link rel="stylesheet" href="index.css"> -->
    <title>Protocolo MQTT - Redes 1</title>
  </head>
  <body>
<body>

<!-- Navbar --> 

<nav class="navbar sticky-top navbar-dark bg-dark navbar-expand-lg">
    <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav">
            <a class="nav-link" href="#introducao">Introdução</a>
            <a class="nav-link" href="#forenseRedes">Ciência Forense em Redes</a>
            <a class="nav-link" href="#papelInternet">Papel da Internet na Análise Forense</a>
            <a class="nav-link" href="#rastrosFisicaEnlace">Rastros Digitais nas Camadas Física e de Enlace</a>
            <a class="nav-link" href="#investigacaoRedeTransporte">Investigação nas Camadas de Rede e Transporte</a>
            <a class="nav-link" href="#antiForense">Anti-forense</a>
            <a class="nav-link" href="#conclusao">Conclusão</a>
            <a class="nav-link" href="#perguntas">Perguntas</a>
            <a class="nav-link" href="#bibliografia">Bibliografia</a>
        </ul>
    </div>
</nav>


<div class="jumbotron jumbotron-fluid">
    <!-- Introdução --> 
    <div class="container content" id="introducao">
        <h1 class="display-4 title">Introdução</h1>
        <ul>
        <p class="lead">
            Com o avanço da tecnologia, estamos acompanhando cada vez mais crimes ocorrendo nos espaços digitais das redes. As provas eletrônicas podem ser coletadas de uma ampla gama de fontes, tais como computadores, smartphones, armazenamento remoto, sistemas aéreos não tripulados, equipamentos embarcados em navios, e muito mais.

            <br/><br/>
            Sendo assim, governos no mundo todo estão sendo confrontados com uma necessidade crescente de investigar crimes cometidos parcialmente ou totalmente pela Internet ou outros meios eletrônicos. Foi necessário então, criar procedimentos únicos para buscar, localizar e preservar eficazmente todos os tipos de provas eletrônicas, e nesse contexto surge a Análise Forense Digital.
            <br/><br/>
            Análise Forense Digital é um ramo da ciência forense que trabalha com um conjunto de técnicas para coleta e exame de evidências digitais, reconstrução de dados e ataques, identificação e rastreamento de invasores.
            <br/><br/>
            O principal objetivo da perícia forense digital é extrair dados da evidência eletrônica, analisá-la e apresentar as conclusões para a acusação. Todos os processos utilizam técnicas forenses sólidas para garantir que as descobertas sejam admissíveis em tribunal.
        </p>
        </ul>
    </div>
  

    <br/>
    <!-- Ciência Forense em Redes --> 
    <div class="container content" id="forenseRedes">
        <h1 class="display-4 title">Ciência Forense em Redes</h1>
        <ul>
        <p class="lead">
            
            A análise de um disco rígido é um procedimento relativamente bem definido quando comparado à análise de uma rede, nelas os investigadores enfrentam um número de desafios muito mais complexos. Os dados de sistemas em rede são dinâmicos e voláteis, tornando difícil fazer uma análise de uma rede sobre um recorte temporal. Diferentemente de um computador, não é viável desligar uma rede para realizar a investigação, pois os investigadores possuem a responsabilidade de recolher provas com o mínimo de interrupção aos negócios que dependam da rede, além disso, o fechamento de uma rede resultará na destruição da maior parte das provas digitais nelas contidas.

            <br/><br/>
            Para tornar mais complexas suas operações, ao contrário do crime no mundo físico, um criminoso pode estar em vários lugares de uma rede. Esta distribuição da atividade criminosa torna ainda mais difícil isolar a cena do crime.
            <br/><br/>
            <img src="images/SistemasDistribuidos.png" alt="Sistemas Distribuidos" width="80%">
            <br/><br/>
            Em contrapartida, ter provas distribuídas em muitas máquinas pode ser vantajoso para a investigação. A distribuição das informações dificulta a destruição das evidências, se as provas são danificadas em um computador uma cópia pode ser encontrada em outro. Muitas organizações fazem sobretudo um backup de suas informações regularmente, o que ajuda ainda mais em todo processo.
            <br/><br/>
        </p>
        </ul>
    </div>


    <br/>
    <!-- Papel da Internet na Análise Forense --> 
    <div class="container content" id="papelInternet">
        <h1 class="display-4 title">Papel da Internet na Análise Forense</h1>
        <ul>
        <p class="lead">
          Com o crescimento exponencial do uso da Internet, cada vez mais pessoas estão usando computadores para cometer crimes, e por consequência, aumentando o número de evidências criadas em ambientes digitais. Sentindo-se protegidos por um suposto anonimato, os indivíduos buscam informações na internet que não buscariam no mundo físico e expressam suas opiniões mais controversas, falas que normalmente guardariam para si mesmos.
            <br/><br/>
            Esses indivíduos muitas vezes não possuem o conhecimento técnico para saber que os servidores na Internet guardam uma quantidade significativa de informações sobre suas atividades pessoais. Alguns desses dados são temporários, podendo permanecer nos servidores durante poucos segundos, minutos ou dias, enquanto outras formas de dados digitais podem ser recuperados anos após os incidentes. Estes dados podem nos trazer informações sobre os pensamentos e interesses particulares de um indivíduo, padrões de comportamento na web e onde estava em um dia específico, informações que podem ser muito úteis para uma investigação. Tudo isso torna a Internet um excelente local para encontrar evidências sobre algum suspeito.
            <br/><br/>
            <p class="h4"> Anonimato Online </p>
            <br/><br/>
            Em uma investigação é importante que os investigadores estejam familiarizados com o anonimato on-line para se proteger, e entender como os criminosos o usam, para evitar serem descobertos. Além de ocultar informações pessoais, como o nome, e número de telefone, alguns criminosos usam endereços IP que não estão ligados a eles. Esses endereços IP podem ser obtidos através de ISPs gratuitos, que permitem que pessoas entrem na Internet sem exigir que elas se identifiquem. Servidores de bibliotecas e cibercafés são outros métodos populares de realizar uma conexão à Internet de forma anônima.
            <br/><br/>
            Os investigadores devem usar o anonimato para se proteger enquanto buscam criminosos na Internet, particularmente quando conduzem uma investigação sigilosa. As investigações online podem ser usadas em muitos tipos de atividades criminosas, como jogos de azar online. Ao realizar a investigação é necessário criar várias identidades falsas para fazer transações e reunir informações das organizações que realizam tais crimes.
            br/><br/>
            <p class="h4"> Criptografia </p>
            <br/><br/>
            Para proteger suas mensagens na Internet, alguns indivíduos criptografam seus dados utilizando softwares ou serviços de e-mail especializados. Outros usam o padrão de e-mail seguro (S/MIME) que é integrado em muitos clientes de e-mail. As chaves de criptografia usadas no S/MIME são geralmente armazenadas no sistema do usuário, e protegidas por uma senha. Entretanto, estas chaves também podem ser geradas e armazenadas em um dispositivo de hardware específico para esse contexto, como o iButton, um dispositivo portátil que destruirá as chaves de criptografia que contêm se forem adulteradas.
            <br/><br/>
            <img src="images/email.jpg" alt="Sistemas Distribuidos" width="80%">
            <br/><br/>
            Contudo, não é viável decifrar o tráfego de uma rede, e é mais eficaz buscar e recuperar as provas digitais a partir dos sistemas finais. Os criminosos mais experientes já perceberam isso, e ao invés de tentar obter cartões de crédito enquanto são transmitidos entre o cliente e o servidor através de uma conexão criptografada Secure Sockets Layer (SSL), os criminosos têm como alvo os pontos finais da comunicação. Os hackers geralmente roubam cartões de crédito instalando um vírus Trojan nos sistemas dos indivíduos e monitorando suas teclas, ou invadindo o servidor e roubando o arquivo que contém informações de cartão de crédito.
        </p>
        </ul>
    </div>

    <br/>
    <!-- Rastros Digitais nas Camadas Física e de Enlace --> 
    <div class="container content" id="rastrosFisicaEnlace">
        <h1 class="display-4 title">Rastros Digitais nas Camadas Física e de Enlace</h1>
        <ul>
        <p class="lead">
            As camadas físicas e de enlace fornecem a base para tudo em uma rede. A camada física é o meio que transporta os dados, como os cabos, ondas de rádio, microondas ou lasers. A camada de enlace une o computador à camada física e inclui o método de transmissão da comunicação. As placas de rede fazem parte desta camada de enlace, conectando computadores aos cabos de rede. Cada placa tem um endereço único (endereço MAC) que pode ser usado para determinar qual host foi usado para cometer um crime. 
            <br/><br/>
            A abordagem mais comum para a coleta de provas digitais sobre as camadas físicas e de enlace de dados, é conhecida como “eavesdropping” (escutar secretamente). Com a ajuda de uma ferramenta de monitoramento de rede, como um sniffer, os investigadores (ou criminosos) podem capturar grandes quantidades de informações enquanto elas viajam através de uma rede. Esta abordagem de coleta de tráfego da rede é comparável a fazer um backup de um disco rígido, com o sniffer conseguindo capturar cada byte transmitido na rede. Os investigadores digitais podem usar um sniffer para monitorar o computador de um criminoso em uma rede e recuperar imagens, anexos de e-mail ou qualquer outra coisa que os infratores tenham transmitido na rede.
            <br/><br/>
            <img src="images/sniffer.png" alt="Sistemas Distribuidos" width="80%">
            <br/><br/>
            Até recentemente, os registros de atividades nas camadas física e de enlace eram raramente guardados por uma organização. Registar todas as informações que passam por uma rede é um processo custoso, e pode resultar em arquivos de registro muito grandes. Entretanto, como o armazenamento está se tornando mais barato e as ferramentas de monitoramento, mais desenvolvidas, cada vez mais organizações estão guardando tais registros. Sem estes tipos de logs, torna-se muito mais difícil obter provas digitais das camadas físicas e de enlace, pois a maioria dos dados não são armazenados por muito tempo. 
        </p>
        </ul>
    </div>

    <br/>
    <!-- Investigação nas Camadas de Rede e Transporte -->
    <div class="container content" id="investigacaoRedeTransporte">
        <h1 class="display-4 title">Investigação nas Camadas de Rede e Transporte</h1>
        <ul>
        <p class="lead">
            Texto em construção...
            <br/><br/>
            Mais Texto
        </p>
        </ul>
    </div>

    <br/>
    <!-- Anti-forense -->
    <div class="container content" id="antiForense">
        <h1 class="display-4 title">Anti-forense</h1>
        <ul>
          <p class="lead">
          Após invadir um sistema, o atacante pode utilizar de várias formas para dificultar que peritos forenses descubram quem foi o responsável pelo ato. Isso pode ser feito deletando rastros, criptografando vestígios, criando pistas falsas, aumentando o tempo de análise do perito, manipulando dados em mídias externas…
          <br/><br/>
          Alguns destes métodos são:

        <p class="h4"> Criptografia </p>
        <ul style="list-style: none;">
          A criptografia torna as informações do arquivo cifradas com base em uma chave. Dessa forma, só consegue acesso aos dados reais o usuário que possuir a chave de criptografia.            
          <br/><br/>
          Diferente do que se pode imaginar, decifrar a chave de criptografia não é algo viável uma vez que, se tratando de uma boa criptografia, a única forma de descobri-la seria a força bruta, o que levaria muitos anos.
        </ul>

        <br/><br/>
        <p class="h4"> Esteganografia </p>
        <ul style="list-style: none;">
          Esteganografia é utilizar uma outra mídia para esconder uma determinada informação. Essas outras mídias são, geralmente, de áudio ou imagem.
        </ul>

        <br/><br/>
        <p class="h4"> Wiping </p>
        <ul style="list-style: none;">
          O wipe é a sobre-escrita de dados e metadados anteriormente salvos na máquina, assim como slack-spaces.
        
          <br/><br/>
          <p class="h5"> Slack-spaces </p>
          <ul style="list-style: none;">
            Um disco rígido vem de fábrica dividido em setores, geralmente de 512 bytes. O sistema operacional agrega esses setores em clusters (ou blocos), e separa um número inteiro de clusters para cada arquivo.
            <br/><br/>
            A diferença entre o tamanho lógico do arquivo e o espaço físico do cluster é o slack space. Nele ficam dados sobre os antigos arquivos que já foram guardados naqueles endereços de memória.
            <br/><br/>
            <img src="images/slackspace.webp" width="50%" alt="...">
          </ul>
        </ul>
        
        <br/><br/>
        <p class="h5"> Proxy e VPN </p>
        <ul style="list-style: none;">
          Tanto o Proxy como a VPN mascaram o IP da máquina cliente, de forma que o servidor só tem conhecimento do IP do intermediário.
          <img src="images/proxy.svg.png" width="100%" alt="...">
        </ul>

    </div>

    <br/>
    <!-- Conclusão -->
    <div class="container content" id="conclusao">
        <h1 class="display-4 title">Conclusão</h1>
        <ul>
        <p class="lead">
            Texto em construção...
            <br/><br/>
            Mais Texto
        </p>
        </ul>
    </div>

    <br/>
    <!-- Perguntas -->
    <div class="container content" id="perguntas">
        <h1 class="display-4 title">Perguntas</h1>
        <ul>
        <p class="lead">
            Texto em construção...
            <br/><br/>
            Mais Texto
        </p>
        </ul>
    </div>

    <br/>
    <!-- Bibliografia -->
    <div class="container content" id="bibliografia">
        <h1 class="display-4 title">Bibliografia</h1>
        <ul>
        <p class="lead">
            Texto em construção...
            <br/><br/>
            Mais Texto
        </p>
        </ul>
    </div>
  


<!-- TRABALHO REFERENCIA ABAIXO --> 


    <!-- Papel da Internet na Análise Forense --> 
    <hr class="my-4" id="papelInternet"> 
    <div class="container content">
        <h1 class="display-4 title">Papel da Internet na Análise Forense</h1>
        <p class="lead">

        </p>
        <figure class="figure centralizado">
            <img src="pubsub.gif" class="figure-img tamanho img-fluid rounded" alt="...">
            <figcaption class="figure-caption text-right">Figura 3 - Mensagens no Padrão Publish-Subscribe. Fonte:https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c</figcaption>
        </figure>
    </div>

  <!-- Como funciona --> 
  <hr class="my-4" id="comofunciona">
    <div class="container content" >
      <h1 class="display-4 title">Como funciona</h1>
      <ul style="list-style: none;">
        <li>
            <p class="h4"> Atores do Sistema </p>
            <ul style="list-style: none;">
              <li class="h5">
                Broker
              </li>
              <p class="lead">
                  O Broker é o servidor intermediário da informação. É ele quem recebe os dados enviados pelos sensores e é nele onde esses dados são tratados e passados adiante. Podem existir mais de um broker em um sistema, que vão compartilhar os dados recebidos entre si baseado nos clientes que possuem e nos dados requisitados por eles.
              </p>
              <li class="h5">
                Cliente
              </li>
              <p class="lead"> 
                  O Cliente possui duas áreas de atuação sobre a informação: Postagem e Recebimento, "publish" e "subscriber", respectivamente. Ele pode escolher em qual área atuar, sendo possível trabalhar na Postagem, no Recebimento ou nos dois ao mesmo tempo. Mas independente de qual caso ele escolha, sempre será necessária a presença de um Broker para realizar a intermediação dos dados entre todos os clientes.
              </p>
            </ul>
        </li>

        <li>
            <p class="h4"> Relação Cliente x Broker </p>
        </li>
        <p class="lead">
            Todas as informações recebidas pelo Broker e passadas adiante são organizadas em um formato hierárquico, de acordo com seus tópicos. Isso significa que um dado captado e enviado para o broker fará parte de apenas 1 tópico, enquanto um outro dado diferente fará parte de um outro tópico, e assim por diante. Um exemplo que podemos dar é o seguinte:
        </p>
        <p class="lead">
            “Foram posicionados dois sensores numa plantação. Um deles é utilizado para medir a umidade do solo enquanto que o outro mede a temperatura local. Ambos estão conectados a um servidor para onde enviarão os dados captados a cada 30 minutos.”
        </p>
        <p class="lead">
            Nesse exemplo ambos os sensores são <b>publishers</b>, ou seja, enviam seus dados para um broker que realiza o armazenamento e controle desses dados. Entretanto, eles não serão armazenados no mesmo local (sob o mesmo tópico). Os dados referentes à temperatura local serão guardados em um tópico “Temperatura”, por exemplo, enquanto que os dados referentes à umidade do solo serão guardados em um tópico “Umidade”. Além desses 2 clientes, também teremos outros clientes, agora <b>subscribers</b>. Esses serão, por exemplo, Raspberry Pis conectados ao sistema de irrigação do local. O raspberry receberá, do broker, os dados referentes à umidade do solo e temperatura do local e realizará sua tarefa.
        </p>
        <p class="lead">
            Quanto a esse “receber os dados do broker”, é exatamente isso. Não é o cliente quem pede ao servidor pelos dados. Como ele já está listado em um devido tópico, o broker sabe que deve mandar esses novos dados para esse receptor, excluindo a necessidade de uma requisição. E além desse benefício, esse método também permite que clientes publishers não necessitem saber para quem esses dados devem ser mandados, já que é um trabalho do Broker.
        </p>
        <li>
            <p class="h4"> Transmissão de Dados </p>
            <p class="lead">
                O protocolo MQTT utiliza outro protocolo chamado TCP para a transmissão de dados. Além do TCP, também é usado o MQTT-SN, que é usado para outros tipos de transporte como UDP ou Bluetooth.
            </p>
        </li>
        <li>
          <p class="h4"> Header </p>
          <p class="lead">
            O Header do MQTT pode variar de 2 a 5 bytes. Em relação ao primeiro byte obrigatório, os 4 primeiros bits referem-se ao tipo de mensagem, o bit seguinte refere-se ao indicador de mensagem duplicada, dois bits para identificar o QoS(qualidade de serviço) do pacote e bit para indicar de se a mensagem deve ser retida ou não para quando alguém se conectar receber a última mensagem enviada. Os próximos 4 bytes irão definir o tamanho do resto do pacote, podendo ir de 0 a 268 435 455 bits. O restante são informações que podem variar e não existe um padrão.
          </p>
      </li>
      <figure class="figure centralizado">
        <img src="mqtt-header.jpg" class="figure-img tamanho img-fluid rounded" alt="...">
        <figcaption class="figure-caption text-right">Figura 4 - MQTT Header. Fonte:http://www.rfwireless-world.com/Tutorials/MQTT-tutorial.html</figcaption>
      </figure>
      <p class="h4"> Tipos de mensagens </p>
      <p class="lead">Primeiramente iremos falar dos 3 principais tipos de mensagem e em seguida teremos uma tabela com todos os tipos de mensagens disponiveis no protocolo e repestivos valores que devem ser enviados no header para identificar a mensagem.</p>
        <li>
            <ul style="list-style: none;">
                <li class="h5">
                  Connect
                </li>
                <p class="lead">
                    Tenta criar uma conexão com o Broker e espera até que a conexão seja estabelecida, começando a escutar as mensagens publicadas. 
                </p>
                <li class="h5">
                  Disconnect
                </li>
                <p class="lead"> 
                    Espera que até o cliente terminar alguma ação que esteja realizado e finaliza a conexão TCP/IP, parando assim de escutar as mensagens que serão publicadas.
                </p>
                <li class="h5">
                    Publish
                  </li>
                  <p class="lead"> 
                      Retorna a informação que foi enviada pelo cliente MQTT.
                  </p>
              </ul>
        </li>
        <br/>
        <br/>
        <p class="h5">Tabela de mensagens</p>

            <table class="table">
              <thead>
                <tr>
                  <th scope="col">Valor</th>
                  <th scope="col">Nome</th>
                  <th scope="col">Direção</th>
                  <th scope="col">Descrição</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th scope="row">0</th>
                  <td>Reservado</td>
                  <td>Proibido</td>
                  <td>Reservado</td>
                </tr>
                <tr>
                  <th scope="row">1</th>
                  <td>CONNECT</td>
                  <td>Cliente para Servidor</td>
                  <td>Requisição do cliente para conectar ao servidor</td>
                </tr>
                <tr>
                  <th scope="row">2</th>
                  <td>CONNACK</td>
                  <td>Servidor para Cliente</td>
                  <td>Reconhecimento da conexão</td>
                </tr>
                <th scope="row">3</th>
                <td>PUBLISH</td>
                <td>Cliente para Servidor ou Servidor para cliente</td>
                <td>Publicar mensagem</td>
              </tr>
              <th scope="row">4</th>
              <td>PUBACK</td>
              <td>Cliente para Servidor ou Servidor para cliente</td>
              <td>Reconhecimento da publicação</td>
            </tr>
            <th scope="row">5</th>
            <td>PUBREC</td>
            <td>Publicação recebida</td>
            <td>Publicação recebida(parte 2 do QoS=1)</td>
          </tr>
          <th scope="row">6</th>
          <td>PUBREL</td>
          <td>Cliente para Servidor ou Servidor para cliente</td>
          <td>Publicação lançada(parte 2 do QoS=2)</td>
        </tr>
        <th scope="row">7</th>
        <td>PUBCOMP</td>
        <td>Cliente para Servidor ou Servidor para cliente</td>
        <td>Publicação completa(parte 3 do QoS=2)</td>
      </tr>
      <th scope="row">8</th>
      <td>SUBSCRIBE</td>
      <td>Cliente para Servidor</td>
      <td>Pedido de inscrição</td>
    </tr>
    <th scope="row">9</th>
    <td>SUBACK</td>
    <td>Servidor para cliente</td>
    <td>Reconhcimento de inscrição</td>
  </tr>
  <th scope="row">10</th>
  <td>UNSUBSCRIBE</td>
  <td>Cliente para Servidor</td>
  <td>Pedido de desinsção</td>
</tr>
<th scope="row">11</th>
<td>UNSUBACK</td>
<td>Servidor para cliente</td>
<td>Reconhecimento desinscrição</td>
</tr>
<th scope="row">12</th>
<td>PINGREQ</td>
<td>Requisição</td>
<td>Requisição PING</td>
</tr>
<th scope="row">13</th>
<td>PINGRESP</td>
<td>Servidor para cliente</td>
<td>Resposta PING</td>
</tr>
<th scope="row">14</th>
<td>DISCONNECTy</td>
<td>Cliente para Servidor</td>
<td>Cliente esta desconectado</td>
</tr>
<th scope="row">15</th>
<td>Reservado</td>
<td>Proibido</td>
<td>Reservado</td>
</tr>

              </tbody>
            </table>
            <br/>
            <br/>
        <li>
            <p class="h4"> Casos Específicos </p>
            <p class="lead">
              Caso um tópico não possua nenhum subscriber e o Broker receber uma informação referente a este tópico, tal informação será deletada. Isso só não acontecerá caso seja especificado pelo publisher que tal dado deve ser armazenado, o que é uma prática muito usada, pois permite que os subscribers possam ter a informação mais atualizada sem ter que esperar o publisher enviar a nova informação.
            </p>
            <p class="lead">
                Um outro caso é quando um publisher se conecta pela primeira vez a um Broker. Durante essa primeira conexão ele tem a oportunidade de definir uma mensagem padrão que será enviada aos subscribers caso o Broker perceba que esse publisher se desconectou dele.
              </p>
        </li>
      </ul>
      <figure class="figure centralizado">
        <img src="mqtt_connection.png" class="figure-img img-fluid tamanho rounded " alt="...">
        <figcaption class="figure-caption text-right">Figura 5 - Exemplo de conexão MQTT com QoS-0 e flag de armazenamento da mensagem. Fonte: https://commons.wikimedia.org/wiki/File:MQTT_protocol_example_without_QoS.svg</figcaption>
      </figure>
    </div>

  <!-- Aplicações MQTT --> 

  <hr class="my-4" id="aplicacoesmqtt">
    <div class="container content">
      <h1 class="display-4 title">Como usar o protocolo MQTT</h1>
      <p class="lead">
        Assim como já foi comentado, o protocolo MQTT é principalmente utilizado em aplicações de IoT, devido a sua simplicidade e facilidade de implementação. Além de aplicações de IoT, alguns usos muito comuns são para a obetenção de dados em tempo real.
      </p>
      <p class="lead">
        Podemos citar o exemplo apresentado no tópico acima "Como funciona", onde o protocolo MQTT é utilizado para se obter informações da temperatura e nível de umidade do solo. Caso o solo esteja pouco úmido e a temperatura esteja alta, por exemplo, o sistema de irrigação será ativado.
      </p>
      <p class="lead">
        Os usos desse protocolo depende apenas da criatividade do desenvolvedor. Podem ser criados sistemas de controle de mercadorias, automação de processos, controle de fluxo de pessoas, controle para eficiência energética, entre muitos outros.
      </p>

      <p class="h4"> Como começar a usar o protocolo MQTT </p>

      <p class="lead">
        Atualmente existem inúmeras implementações tanto para brokers como para clientes MQTT em diversas linguagens, tais como Python, JavaScript, C#, entre outros. Podemos encontrar facilmente várias dessas implementações na internet, sendo boa parte delas open source e de fácil acesso e download pelo público.
      </p>
      <p class="lead">
        Uma dessas implementações é o broker Mosquitto. Sendo um dos brokers mais utilizados atualmente devido à sua simplicidade e facilidade de implementação, esta tecnologia open source ganhou um grande espaço no mercado de IoT por estar intimamente relacionado com o protocolo MQTT.
      </p>
      <p class="lead">
        Nós utilizaremos o Mosquitto para exemplificar alguns métodos e mostraremos também como instalá-lo e como começar a implementá-lo em uma aplicação real. Caso você tenha interesse em outros exemplos de Brokers, listaremos ao final algumas opções que podem ser utilizadas.
      </p>

      <p class="lead">
        O "Mosquitto" pode ser facilmente baixado para vários sistemas operacionais. Os arquivos de download podem ser encontrados na página oficial do broker, na aba de downloads. Ao baixar o broker escolhido, este vai ser utilizado para rodar o servidor onde o sistema e o relacionamento entre os clientes e o broker será hospedado.
      </p>
      <p class="lead">
        A partir deste momento já é possível testar seu broker. Este teste pode ser realizado pelo próprio prompt de comando do computador, onde podem ser feitas as inscrições de clientes em certos tópicos. Ao mesmo tempo, caso você já possua uma aplicação web é possível relacioná-la ao seu broker (ao seu servidor), adicionando a aplicação tanto como um cliente <b>subscriber</b> como um cliente <b>publisher</b>.
      </p>
      <p class="lead">
        Como já foi citado anteriormente, vários sistemas podem ser utilizados como clientes deste protocolo. Podemos utilizar sensores, que pegariam alguns dados do ambiente e os enviariam pro broker, por exemplo. Podemos usar um RaspberryPi, que pegaria esses dados do broker - que foram enviados pelos sensores - para controlar alguma máquina. Também podemos ter um sistema, como foi apontado acima, que usaria esses mesmos dados enviados ao broker pelos sensores, mas com um objetivo que pode ser diferente ou não do RaspberryPi.
      </p>
        
      <p class="h4">
        Outros tipos de Brokers
      </p>
      <br/>
      <br/>

      <ul style="list-style: none;">
        <li class="h5">
          Brokers
        </li>
        <figure class="figure centralizado">
            <img src="brokers.PNG" class="figure-img img-fluid tamanho rounded" alt="...">
            <figcaption class="figure-caption text-right">Figura 6 - 5 Serviços de broker online para teste . Fonte: https://diyprojects.io/8-online-mqtt-brokers-iot-connected-objects-cloud/#.XPcB6YhKjIU</figcaption>
        </figure>
      </ul>

    </div>

    <!-- Qualidade de Serviço --> 

    <hr class="my-4" id="qos">
    <div class="container content">
      <h1 class="display-4 title">Qualidade de serviço</h1>
      <p class="lead">
        No protocolo MQTT nós temos 3 qualidades de serviço(QoS) e cada conexão com o broker pode especificar qual será utilizada., sendo estas: "no máximo uma vez", "no mínimo uma vez" e "exatamente uma vez".
      </p>
      <ul>
        <li>
      <p class="h4">
        QoS 0 - No máximo uma vez
      </p>
    </li>
      <p class="lead">
        Conhecido como fire and forgot (atirar e esquecer), nesse QoS a mensagem é enviada apenas uma vez e não haverá passos seguintes, dessa forma a mensagem não será armazenada, nem haverá um feedback para saber se ela chegou ao destinatário. 
      </p>
      <p class="lead">
        Esse modo de transferência é o mais rápido, porém o menos seguro já que a mensagem será perdida caso o envio falhe ou o cliente esteja desconectado.
      </p>
      <figure class="figure centralizado">
          <img src="QoS-0.png" class="figure-img img-fluid tamanho rounded " alt="...">
          <figcaption class="figure-caption text-right">Figura 7 - Único pacote enviado na troca de mensagem com nQoS 0 . Fonte: https://www.hivemq.com/blog/</figcaption>
        </figure>
      <li>
      <p class="h4">
        QoS 1 - Pelo menos uma vez
      </p>
    </li>
      <p class="lead">
        Nesse modo de transferência, a mensagem é entregue pelo menos uma vez, havendo uma espera da recepção de feedback da entrega da mensagem, o chamado PUBACK. Não recebendo o PUBACK, a mensagem continuará sendo enviado até que haja o feedback. Nesse QoS pode acontecer da mensagem ser enviada diversas vezes e ser processada diversas vezes. 
      </p>
      <p class="lead">
        Para que haja o envio da mensagem mais de uma vez, a mensagem precisa ser armazenada. Ela será excluída do receptor após ter recebido o feedback de confirmação do envio. 
      </p>
          <figure class="figure centralizado">
              <img src="QoS-1.png" class="figure-img img-fluid tamanho rounded" alt="...">
              <figcaption class="figure-caption text-right">Figura 8 - Pacotes enviados na troca de mensagem com QoS 1 . Fonte: https://www.hivemq.com/blog/</figcaption>
            </figure>
            <li>
      <p class="h4">
        QoS 2 - Exatamente uma vez
      </p>
    </li>
      <p class="lead">
        Nesse modo de transferência, a mensagem é entregue exatamente uma vez, necessitando que a mensagem seja armazenada localmente no emissor e no receptor até que seja processada. Para garantir a segurança desse QoS é necessário o envio de 2 pares de request-response(chamado de four-part handshake), onde temos o envio da mensagem(PUBLISH), a resposta de recepção(PUBREC), o aviso do recebimento do PUBREC(PUBREL) e a confirmação de que o processo foi concluído e pode ser feita a exclusão(PUBCOMP).  Após o recebimento do PUBREL, o receiver pode excluir a mensagem e ao sender receber o PUBCOMP ele poderá excluir a mensagem.
      </p>
      <figure class="figure centralizado">
          <img src="QoS-2.png" class="figure-img img-fluid tamanho rounded " alt="...">
          <figcaption class="figure-caption text-right">Figura 9 - Pacotes enviados na troca de mensagem com QoS 2 . Fonte: https://www.hivemq.com/blog/</figcaption>
        </figure>
      
    </ul>
    </div>

  <!-- Vantagens do MQTT --> 

  <hr class="my-4" id="vantagensmqtt">
    <div class="container content">
      <h1 class="display-4 title">Vantagens</h1>
      <p class="lead">
        Em relação às vantagens, três ficam muito claras, o baixo consumo de memória, baixa necessidade de processamento para o envio de mensagem e baixo consumo de banda. Como o publisher não envia a informação direto para os subscribers, ele não precisa guardar a informação de todos os seus subscritores e nem precisa fazer várias envios de informação(uma para cada subscriber).
      </p>
      <p class="lead">
        Apenas é necessário que ele realize um envio de informação para o broker com a informação que ele quer que seja enviada daquele tópico, dessa forma o processamento realizado e o consumo de memória do Publisher pode ser reduzido. Além disso, o header de uma mensagem no protocolo MQTT é muito menor do que um Header no protocolo HTTP, o que economiza muito o consumo de banda.
      </p>
    </div>

  <!-- Perguntas --> 

  <hr class="my-4" id="perguntas">
    <div class="container content">
        <h1 class="display-4 title">Perguntas</h1>
        <h4>Quais as vantagens do MQTT sobre o HTTP?</h4>
        <p class="lead">As vantagens são: baixo consumo de memória, a baixa necessidade de processamento para o envio de mensagem e o baixo consumo de banda. A primeira referente a necessidade de armazenar apenas a informação dos brokers que estão conectados e os tópicos e ao envio de pacotes pequenos, considerando que o mqtt possui um header mais enxuto.</p>
        <h4>Explique o paradigma Publish-subscribe.</h4>
        <p class="lead">Nesse paradigma possuímos três papéis, o broker, o publisher e o subscriber. Nesse paradigma o Publisher enviará mensagens referentes a tópicos, o subscribe irá assinar tópicos para receber mensagens sobre ele e o Broker receberá as mensagens dos publishers e será responsável em enviar as mensagens para os subscribers que tenham interesse nesse assunto específico. </p>
        <h4>Explique o papel do Broker, dos clientes subscribers e dos clientes publishers.</h4>
        <p class="lead">O Broker é um intermediador entre os clientes do protocolo. É ele quem vai receber as informações de um cliente publisher e vai enviar essa informação aos clientes subscribers inscritos no tópico referente àquela informação.
          O Cliente Publisher é aquele que capta uma informação e a envia ao broker. Um exemplo seria um sensor, que envia os dados captados (como temperatura), ao broker que, por sua vez, enviará esse dado aos clientes subscribers.
          Cliente Subscriber é o cliente que recebe uma informação do broker. Ele deve se inscrever em tópicos definidos pelo broker, cada um sobre uma certa informação, que por sua vez foi captada por um cliente publisher.
          Vale dizer que o cliente pode ser, ao mesmo tempo, publisher e subscriber, ou seja, enviar e consumir dados ao/do broker.</p>
        <h4>Quais são as QoS (qualidade de serviço) disponíveis no protocolo e como são caracterizadas?</h4>
        <p class="lead">São 3 qualidades de serviço. Sendo o QoS=0, envio de mensagem pelo no máximo uma vez, QoS=1,envio de mensagem pelo menos uma vez e QoS=2, envio de mensagem exatamente uma vez.</p>
        <h4>Qual o tamanho do header fixo do MQTT?</h4>
        <p class="lead">2 bytes</p>
    </div>

  <!-- Conclusões --> 

<hr class="my-4" id="conclusoes">
    <div class="container content">
      <h1 class="display-4 title">Conclusões</h1>
      <p class="lead">
        O MQTT se mostra um ótimo protocolo para ser utilizado em serviços que não precisam de muita informação sendo enviada e não precisam de um histórico sendo guardado das modificações. Por ser fácil de implementar e por enviar informações pequenas, se mostra uma ótima opção dentro do mercado de IoT, já que não é necessário muita banda nem muito processamento para que a comunicação ocorra. Dessa forma, conseguimos ter um bom resultado em situações em que precisamos de soluções de baixo custo e em situação com conexões não muito boas. Hoje em dia com Brokers gratuitos e a facilidade de implementar esse tipo de conexão, fica ainda mais fácil de testar esse tipo de serviço e implementar em projetos.
      </p>
      <p class="lead">
        No geral o MQTT mostra uma vantagem clara em relação ao HTTP, porém em algumas situações será encontrando um gargalo em relação ao MQTT. Considerando que a conexão dos clientes ao broker são conexões contínuas, que não são fechadas até o cliente se desconectar, podem haver situações onde temos várias conexões abertas em paralelo no mesmo roteador e devido às limitações desse roteador, podemos observar um congestionamento da rede, algo que não aconteceria com o HTTP já que as conexões são abertas apenas para verificar se houve uma modificação e logo em seguida é fechada, evitando assim que muitas conexões permaneçam abertas simultaneamente. 
      </p>
      <p class="lead">
        No geral saber qual é o melhor protocolo a ser usado é uma decisão de projeto que varia para cada situação, cada protocolo tem suas vantagens e desvantagens, assim recomendamos que seja avaliada a situação de acordo com os gargalos que podem ser apresentados utilizando cada tipo de protocolo e os custos referentes a utilização e aquele que obtiver os melhores dados seja escolhido. 
      </p>
    </div>

    <!-- Bibliografia  --> 

  <hr class="my-4" id="bibliografia">
    <div class="container content">
      <h1 class="display-4 title">Bibliografia</h1>
      <ul style="list-style: none;">
        <li>
          <i>Conhecendo o MQTT. IBM.</i> Disponível em: https://www.ibm.com/developerworks/br/library/iot-mqtt-why-good-for-iot/index.html . Acesso em: 31 mai. 2019.
        </li>
        <li>
          <i>MQTT Essentials: Part 1 – Introducing MQTT. HIVEMQ.</i> Disponível em: https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/ . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>MQTT Version 3.1.1. OASIS.</i> Disponível em: http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>MQTT Version 5.0. OASIS.</i> Disponível em: https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>Publisher-Subscriber pattern. MICROSOFT.</i> Disponível em: https://docs.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>Qualidades de serviço fornecidas por um cliente MQTT. IBM.</i> Disponível em: https://www.ibm.com/support/knowledgecenter/pt-br/SSFKSJ_8.0.0/com.ibm.mq.dev.doc/q029090_.htm . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>MQTT Essentials Part 6: Quality of Service 0, 1 & 2. HIVEMQ.</i> Disponível em: https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels/ . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>The Observer Pattern. O'REILLY.</i> Disponível em: https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s05.html . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>Pub/Sub Messaging. Amazon.</i> Disponível em: https://aws.amazon.com/pub-sub-messaging/ . Acesso em: 08 mai. 2019.
        </li>
        <li>
          <i>MQTT community. MQTT Community Wiki.</i> Disponível em: https://github.com/mqtt/mqtt.github.io/wiki . Acesso em: 04 jun. 2019.
        </li>
    </div>
  </div>



  <!-- Informações do Grupo --> 
  <div class="jumbotron jumbotron-fluid bg-dark text-light">
    <div class="container content">
    <p>Redes de Computadores I - EEL878 - 2019.1</p>
    <p>Departamento de Eletronica - Escola Politecnica UFRJ</p>
    <p>Tema: MQTT</p>
    <p>
      Alunos: Renan Neri, Matheus Lomba e Gabriel Bulhões
    </p>
    <p>"Este trabalho foi totalmente produzido pelos autores que declaram não terem violado os direitos autorais de terceiros, sejam eles pessoas físicas ou jurídicas. Havendo textos, tabelas e figuras transcritos de obras de terceiros com direitos autorais protegidos ou de domínio público tal como idéias e conceitos de terceiros, mesmo que sejam encontrados na Internet, os mesmos estão com os devidos créditos aos autores originais e estão incluídas apenas com o intuito de deixar o trabalho autocontido. O(s) autor(es) tem(êm) ciência dos Artigos 297 a 299 do Código Penal Brasileiro e também que o uso do artifício de copiar/colar texto de outras fontes e outras formas de plágio é um ato ilícito, condenável e passível de punição severa. No contexto da Universidade a punição não precisa se restringir à reprovação na disciplina e pode gerar um processo disciplinar que pode levar o(s) aluno(s) à suspensão;"</p>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  </body>
</html>
